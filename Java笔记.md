# Java笔记

## 基础语法

### 转义字符

\t空格对齐

\n换行

\\\一个\

\\"一个“

\r回车

### Dos命令

dir 查看当前目录

cd d:\acb\dad切换到当前盘的其他目录下  

cd.. 切换到上级

cd\ 切换到根目录

tree d:\abc 查看目录树

cls清屏

### jdk jre jvm的关系



### 配置环境



###  Java编写步骤



### Java编写规范 



### +的使用



###   Java数据类型



### double除法

![image-20220329201122573](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220329201122573.png)

### 字符转换

![image-20220330161727682](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220330161727682.png)

byte,short 不能自动转换成char

byte,short,char 三者计算时先换成int类型

boolean不参与类型的自动转换

![image-20220330193601969](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220330193601969.png)

### 字符串转为字符

![image-20220330194322355](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220330194322355.png)

### JAVA取模运算

a%b=a-a/b*b

### 逻辑运算符

![image-20220331200702980](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220331200702980.png)

### 短路与和或

![image-20220331205135782](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220331205135782.png)

![image-20220331205924291](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220331205924291.png)

### 运算优先级

![image-20220402110357676](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220402110357676.png)

### 原反补

![image-20220402132858109](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220402132858109.png)

### 位运算

![image-20220402133658955](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220402133658955.png)

### switch

![image-20220402171804777](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220402171804777.png)

### break

![image-20220403114212968](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220403114212968.png)

### switch

![image-20220404194057042](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220404194057042.png)

### 数组扩容

![image-20220405210555007](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220405210555007.png)

冒泡排序

![image-20220405211035477](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220405211035477.png)

### 动态创建二维数组

![image-20220406113219128](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406113219128.png)

![image-20220406112821307](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406112821307.png)

### 方法

![image-20220406130309536](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406130309536.png)

![image-20220406130319587](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406130319587.png)

![image-20220406130408575](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406130408575.png)

### 克隆对象

![image-20220406154643304](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406154643304.png)

### 作用域

![image-20220406161411684](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406161411684.png)

![image-20220406161615389](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406161615389.png)

![image-20220406162308312](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406162308312.png)

![image-20220406162343135](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406162343135.png)

### 构造器

![image-20220406163533281](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406163533281.png)

![image-20220406171313076](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406171313076.png)

### 反编译

![image-20220406174300470](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220406174300470.png)

### this

![image-20220407100838398](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220407100838398.png)

![image-20220407101105306](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220407101105306.png)

idea快捷键

![image-20220407110600805](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220407110600805.png)

![image-20220407113046385](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220407113046385.png)

### 访问修饰符

![image-20220407114833882](C:\Users\uie\AppData\Roaming\Typora\typora-user-images\image-20220407114833882.png)

### 继承

![image-20220407131608890](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407131608890.png)

![image-20220407132042363](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407132042363.png)

![image-20220407135012820](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407135012820.png)

![image-20220407135026707](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407135026707.png)

![image-20220407135036139](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407135036139.png)

![image-20220407135045941](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407135045941.png)

### 重写

![image-20220407141525092](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407141525092.png)

### 多态

方法的多态

![image-20220407164708023](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407164708023.png)

对象的多态

![image-20220407165054410](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220407165054410.png)

### 调用顺序

父类静态->子类静态->父类普通->父类构造器->子类普通->子类构造器

### 单例设计

![image-20220409171645114](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220409171645114.png)

### final

![image-20220409173223136](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220409173223136.png)\

### 抽象类

![image-20220410104105748](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220410104105748.png) 

### 接口

![image-20220410145001189](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220410145001189.png)

接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰

![image-20220410160718364](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220410160718364.png)



![image-20220410162156923](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220410172458764.png)

![image-20220411100629088](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220411100629088.png)

### 内部类

![image-20220411164435751](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220411164435751.png)

### 匿名内部类

![image-20220412103136051](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220412103136051.png)

基于接口的匿名内部类：new一个接口

![image-20220412110610854](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220412110610854.png)

基于类的匿名内部类

![image-20220412111904397](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220412111904397.png)

![image-20220412151737255](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220412151737255.png)

### 异常

![image-20220414202325123](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220414202325123.png)

**![image-20220414211540929](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220414211540929.png)**

![image-20220417120622984](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220417120622984.png)

#### 自定义异常

![image-20220417122610083](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220417122610083.png)

### 包装类

![image-20220418112011539](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220418112011539.png)

### String的特性

![image-20220419102410410](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419102410410.png)

![image-20220601113637898](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220601113637898.png)

## String常见方法

![image-20220419123425599](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419123425599.png)

![image-20220419131547279](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419131547279.png)

### Stringbuffer

![image-20220419142214897](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419142214897.png)

#### Stringbuffer->string ,string->Stringbuffer

![image-20220419143514638](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419143514638.png)

### stringbulider

![image-20220419171406159](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419171406159.png)

![image-20220419172141655](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220419172141655.png)

### 日期

![image-20220420195454072](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220420195454072.png)

### 日历

![image-20220420195437211](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220420195437211.png)

### LocalData Time

![image-20220421101705316](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421101705316.png)

### String内存布局

![image-20220421113032163](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421113032163.png)

### 集合

![image-20220421114336100](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421114336100.png)

![image-20220421125636166](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421125636166.png)

#### 遍历集合

![image-20220421132809830](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421132809830.png)

![image-20220421131426576](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421131426576.png)

![image-20220421165857928](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421165857928.png)

![image-20220421174731871](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421174731871.png)

![image-20220421195853695](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421195853695.png)

### set

![image-20220421200156942](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421200156942.png)![image-20220421205508192](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220421205508192.png)

![image-20220422103847960](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220422103847960.png)

![image-20220422111307157](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220422111307157.png)

### Map

![image-20220422115537846](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220422115537846.png)

![image-20220423095453352](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423095453352.png)

![image-20220423123519020](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423123519020.png)

#### entry遍历

![image-20220423104615126](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423104615126.png)

![image-20220423105904159](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423105904159.png)

### hashtable

![image-20220423143736624](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423143736624.png)

#### properties

![image-20220423145725975](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423145725975.png)

#### 集合实现类的选择

![image-20220423151038423](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423151038423.png)

### collections

![image-20220423163339596](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423163339596.png)

### 泛型

![image-20220423194048690](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423194048690.png)

![image-20220423201039857](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220423201039857.png)

### 线程

![image-20220427095453228](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095453228.png)

![image-20220427095506453](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095506453.png)

#### 方法

![image-20220427095636237](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095636237.png)

![image-20220427095647253](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095647253.png)

#### 用户线程与守护线程

![image-20220427095734653](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095734653.png)

#### 线程状态

![image-20220427095754091](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095754091.png)

#### 线程同步

![image-20220427095859181](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095859181.png)

![image-20220427095921521](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427095921521.png)



### 文件操作

![image-20220427100239835](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427100239835.png)

![image-20220427100120870](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427100120870.png)

![image-20220427100048077](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427100048077.png)

![image-20220427100026343](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427100026343.png)

<img src="C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427100333116.png" alt="image-20220427100333116" style="zoom:150%;" />

#### objectin/outputstream

![IMG_1138(20220427-121836)](C:/Users/uie/Documents/Tencent%20Files/1010673897/FileRecv/MobileFile/IMG_1138(20220427-121836).JPG)

![IMG_1137(20220427-121019)](C:/Users/uie/Documents/Tencent%20Files/1010673897/FileRecv/MobileFile/IMG_1137(20220427-121019).JPG)

![image-20220427151139666](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427151139666.png)

#### system![image-20220427153744527](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427153744527.png)

![image-20220427153853781](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427153853781.png)

![image-20220427232111870](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220427232111870.png)

### 网络

![image-20220428135145818](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220428135145818.png)

#### 字符流写入

![image-20220428151248123](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220428151248123.png)

### 反射

![image-20220502114404143](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114404143.png)

![image-20220502114418282](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114418282.png)

![image-20220502114428355](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114428355.png)

![image-20220502114440067](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114440067.png)

![image-20220502114449984](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114449984.png)

![

![image-20220502114517310](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114517310.png)]

![image-20220502114534974](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114534974.png)

![

![image-20220502114625447](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114625447.png)](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114600835.png)

![

![image-20220502114719486](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114719486.png)](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114700462.png)

![image-20220502114806027](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220502114806027.png)

## 数据库

### 修改密码登入

解决方案：
到安装的MySQL的目录下，找my.ini文件；

在[mysqld]后添加skip-grant-tables（使用 set password for设置密码无效，且此后登录无需键入密码）

skip-grant-tables #在my.ini，[mysqld]下添加一行，使其登录时跳过权限检查

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316140044994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyb25lcnQ=,size_16,color_FFFFFF,t_70)

尽量少操作(接着如下操作)
重启MySQL服务器。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316140052777.png)

登录mysql，键入mysql –uroot –p；直接回车（Enter）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316140059717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lyb25lcnQ=,size_16,color_FFFFFF,t_70)

键入无效set password for ‘root’@‘localhost’=password(‘123456’);（注意这里有一个分号；一定要带这个分号，不然会一直卡住）
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021031614011979.png)
报了上图的错误之后，输入flush privileges;[命令行](https://so.csdn.net/so/search?q=命令行&spm=1001.2101.3001.7020)执行，再执行 set password for ‘root’@‘localhost’=password(‘123456’);就可以成功设置密码了

再把my.ini的skip-grant-tables删除，然后重启MySQL服务器：net stop mysql ;net start mysql;

设置密码成功。

### 函数

![image-20220504104028209](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220504104028209.png)

![image-20220504104016230](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220504104016230.png)

![image-20220504110424681](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220504110424681.png)

![image-20220504113036468](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220504113036468.png)

![image-20220504194613092](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220504194613092.png)

### 复制表

![image-20220505110050457](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505110050457.png)

### 合并表

![image-20220505110841181](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505110841181.png)

### 左外右外

![image-20220505113543204](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505113543204.png)

### ![image-20220505114336439](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505114336439.png)主键

![image-20220505114621215](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505114621215.png)

![image-20220505195654419](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505195654419.png)

### 外键

![image-20220505213443608](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505213443608.png)

![image-20220505220455088](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220505220455088.png)

![image-20220506195633132](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220506195633132.png)

### 自增长

![image-20220506200047345](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220506200047345.png)

![image-20220506200510513](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220506200510513.png)

### 存储

![image-20220507165128188](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220507165128188.png)

![image-20220507171525092](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220507171525092.png)

![image-20220507182357744](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220507182357744.png)

![image-20220507194336195](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220507194336195.png)

![image-20220507200249286](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220507200249286.png)

![image-20220508161448437](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508161448437.png)

![image-20220508161932413](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508161932413.png)

![image-20220508162124805](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508162124805.png)

![image-20220508162425930](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508162425930.png)

![image-20220508162834609](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508162834609.png)

![image-20220508163246643](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508163246643.png)

![image-20220508172326590](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508172326590.png)

![image-20220508172350566](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508172350566.png)

![image-20220508205943122](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220508205943122.png)

![image-20220509104137876](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220509104137876.png)

![image-20220509110214415](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220509110214415.png)

![image-20220509140337930](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220509140337930.png)

![image-20220510121031236](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510121031236.png)

![image-20220510121019156](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510121019156.png)

![image-20220510120915967](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510120915967.png)

![image-20220510154941181](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510154941181.png)

## 正则表达式

![image-20220510192724506](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510192724506.png)

![image-20220510194604939](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220510194604939.png)



![image-20220511152920171](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511152920171.png)

![image-20220511153122647](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511153122647.png)

![image-20220511154526291](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511154526291.png)

![image-20220511154846438](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511154846438.png)

![image-20220511155039326](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511155039326.png)

![image-20220511160250174](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511160250174.png)

![image-20220511160612031](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511160612031.png)

![image-20220511160859173](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511160859173.png)

![image-20220511230206097](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220511230206097.png)

![image-20220512104413416](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512104413416.png)

![image-20220512111419689](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512111419689.png)

![image-20220512111432625](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512111432625.png)

![image-20220512115443416](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512115443416.png)

![image-20220512131219999](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512131219999.png)

![image-20220512131827252](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220512131827252.png)

## @Autowired

一、在构造函数上定义
关于在构造方法上加@Autowired注解，讲下面几点:
1.带有@Autowired注解（属性required默认为true）的构造方法，在Spring初始化对象实例时，会调用此构造函数，进行对象的实例化。
2.如果构造方法上带有了@Autowired注解，那么这个构造方法不是public修饰的，也可以被实例化。private修饰的，也可以被实例化出来。
3.当一个对象只有一个构造方法时，Spring实例化对象会默认选择这个构造方法进行实例化，无需加@Autowired注解。只有当多个构造方法存在时，才用加@Autowired注解，告诉Spring选择哪个构造方法进行实例化。
4.构造方法的@Autowired且required属性为true只允许存在一个。其他的@Autowired直接的required属性必须设置为false。
5.实例化带参数的构造方法时，Spring会先实例化构造方法中参数对象。

总结:当一个类中有多个构造方法，且我们要选择某一个构造方法进行Spring实例化时，可以在构造方法上加@Autowired注解。

二、在类属性上定义
这种用法是我们最常用的。字段在构造bean之后，在调用任何配置方法之前被注入。这样的配置字段不必是public的。private的也可以被赋值。

三、在方法上定义
定义在其他方法上，当Spring容器调用该类的构造方法实例化完成该类后，会调用@Autowired修饰的方法，并将方法的参数进行实例化。也就是说，我们如果想实例化完成一个类后，执行某个方法时，可以用@Autowired注解来修饰。Spring会自动给我们执行该方法，有点儿类似于init-method的用法。但是必须保证该方法的参数对象在Spring容器中也存在，否则会报错。

四、注意
在BeanPostProcessor类和BeanFactoryPostProcessor类中无法使用@Autowired注解。因为@Autowired注解的收集工作就是由BeanPostProcessor类来完成的，且BeanFactoryPostProcessor类的调用时机先于BeanPostProcessor类。所以这两个类无法使用@Autowired注解。

@Autowired修饰方法时，如果方法的参数传入的是array,Collection或者Map类型的参数，那么Spring在自动注入这些参数时，Spring容器会把集合定义的泛型的所有实例化对象，放入集合中。所以，在这种情况下使用Map作为参数时，map的key必须为String类型，Spring会根据map的value值的对象类型，去实例化对象，最终map的key是value所对应对象类型的beanNames，value就是实例化的对象。

## Java项目

### cli3.x使用vue-axios插件

首先在主入口文件main.js中引用：

```
import { createApp } from 'vue'



import App from './App.vue'



import axios from 'axios'



import VueAxios from 'vue-axios'



const app = createApp(App)



app.use(VueAxios,axios);
```

然后在组件中引用，注意vue3.x没有this

```
axios.get('api/getNewsList')



.then((response)=>{



    console.log(response)



})
```

### vant ui使用

 cnpm i vant -S 

```
import Vant from 'vant'
import 'vant/lib/index.css'

Vue.use(Vant)
```

## Java重要知识点

### JVM

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

### Java 和 C++ 的区别?

我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

### continue、break 和 return 的区别是什么？

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：

1. `continue` ：指跳出当前的这一次循环，继续下一次循环。
2. `break` ：指跳出整个循环体，继续执行循环下面的语句。

`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：

1. `return;` ：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return value;` ：return 一个特定值，用于有返回值函数的方法

### 静态方法为什么不能调用非静态成员?

这个需要结合 JVM 的相关知识，主要原因如下：

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 静态方法和实例方法有何不同？

**1、调用方式**

在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

因此，一般建议使用 `类名.方法名` 的方式来调用静态方法。



```java
public class Person {
    public void method() {
      //......
    }

    public static void staicMethod(){
      //......
    }
    public static void main(String[] args) {
        Person person = new Person();
        // 调用实例方法
        person.method();
        // 调用静态方法
        Person.staicMethod()
    }
}
```

### 重载和重写的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

### 基本类型和包装类型的区别？

- 成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

- 包装类型可用于泛型，而基本类型不可以。

- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。

- 相比于对象类型， 基本数据类型占用的空间非常小。

  ### 包装类型的缓存机制了解么？

  Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

  `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)` 会直接创建新的对象。

![img](https://img-blog.csdnimg.cn/20210422164544846.png)

### 成员变量与局部变量的区别

- **语法形式** ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

- **存储方式** ：从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

- **生存时间** ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

- **默认值** ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

  ### **引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**

  对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

  ```java
  String str4 = new StringBuilder().append(str1).append(str2).toString();
  ```

我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。

不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。

示例代码：

```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```

被 `final` 关键字修改之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。

### `RuntimeException` 及其子类都统称为非受检查异常

常见的有（建议记下来，日常开发中会经常用到）：

- `NullPointerException`(空指针错误)
- `IllegalArgumentException`(参数错误比如方法入参类型错误)
- `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）
- `ArrayIndexOutOfBoundsException`（数组越界错误）
- `ClassCastException`（类型转换错误）
- `ArithmeticException`（算术错误）
- `SecurityException` （安全错误比如权限不够）
- `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)

### 什么是泛型？有什么作用？

**Java 泛型（Generics）** 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList<Persion> persons = new ArrayList<Persion>()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Persion` 对象，如果传入其他类型的对象就会报错。

```java
ArrayList<E> extends AbstractLi
```

###  Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

![image-20220602110700977](C:/Users/uie/AppData/Roaming/Typora/typora-user-images/image-20220602110700977.png)

### 既然有了字节流,为什么还要有字符流?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

### JDK 动态代理和 CGLIB 动态代理对比

1. **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

## [#](https://javaguide.cn/java/basis/proxy.html#_4-静态代理和动态代理的对比) 静态代理和动态代理的对比

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

### 有哪些常见的 IO 模型?

UNIX 系统下， IO 模型一共有 5 种： **同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

### BigDecimal 的用处

《阿里巴巴 Java 开发手册》中提到：**浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。**

### BigDecimal 的使用注意事项

注意：我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。

《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211213102222601.png)

### 总结

浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。

不过，Java 提供了`BigDecimal` 来操作浮点数。`BigDecimal` 的实现利用到了 `BigInteger` （用来操作大整数）, 所不同的是 `BigDecimal` 加入了小数位的概念。

### Java 集合概览

Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collection`接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。对于`Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。

Java 集合框架如下图所示：

![img](https://javaguide.cn/assets/java-collection-hierarchy.1727461b.png)

### 说说 List, Set, Queue, Map 四者的区别？

- `List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。
- `Set`(注重独一无二的性质): 存储的元素是无序的、不可重复的。
- `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### Arraylist 与 LinkedList 区别?

1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
3. 插入和删除是否受元素位置的影响：
   - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
   - `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。
4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
5. **内存空间占用：** `ArrayList` 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。

### 说一说 PriorityQueue

`PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

这里列举其相关的一些要点：

- `PriorityQueue` 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据
- `PriorityQueue` 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- `PriorityQueue` 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

`PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。

### HashMap **遍历从大的方向来说，可分为以下 4 类**：

1. 迭代器（Iterator）方式遍历；
2. For Each 方式遍历；
3. Lambda 表达式遍历（JDK 1.8+）;
4. Streams API 遍历（JDK 1.8+）。

但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：

1. 使用迭代器（Iterator）EntrySet 的方式进行遍历；
2. 使用迭代器（Iterator）KeySet 的方式进行遍历；
3. 使用 For Each EntrySet 的方式进行遍历；
4. 使用 For Each KeySet 的方式进行遍历；
5. 使用 Lambda 表达式的方式进行遍历；
6. 使用 Streams API 单线程的方式进行遍历；
7. 使用 Streams API 多线程的方式进行遍历。

接下来我们来看每种遍历方式的具体实现代码。

#### 1.迭代器 EntrySet

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> entry = iterator.next();
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 2.迭代器 KeySet

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        Iterator<Integer> iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            Integer key = iterator.next();
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 3.ForEach EntrySet

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 4.ForEach KeySet

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        for (Integer key : map.keySet()) {
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 5.Lambda

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        map.forEach((key, value) -> {
            System.out.println(key);
            System.out.println(value);
        });
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 6.Streams API 单线程

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        map.entrySet().stream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java中文社群

#### 7.Streams API 多线程

```
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java中文社群");
        // 遍历
        map.entrySet().parallelStream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
    }
}
```

### 集合转数组

《阿里巴巴 Java 开发手册》的描述如下：

> **使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类 型数组。

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);
```

由于 JVM 优化，`new String[0]`作为`Collection.toArray()`方法的参数现在使用更好，`new String[0]`就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：https://shipilev.net/blog/2016/arrays-wisdom-ancients/

### 数组转集合

**`Arrays.asList()`是泛型方法，传递的数组必须是对象数组，而不是基本类型。**

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 `List` 的唯一元素就是这个数组，这也就解释了上面的代码。

我们使用包装类型数组就可以解决这个问题。

```java
Integer[] myArray = {1, 2, 3};
```



**2、使用集合的修改方法: `add()`、`remove()`、`clear()`会抛出异常。**



```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

`Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。

```java
List myList = Arrays.asList(1, 2, 3);
System.out.println(myList.getClass());//class java.util.Arrays$ArrayList
```

**那我们如何正确的将数组转换为 `ArrayList` ?**

1、手动实现工具类

```java
//JDK1.5+
static <T> List<T> arrayToList(final T[] array) {
  final List<T> l = new ArrayList<T>(array.length);

  for (final T s : array) {
    l.add(s);
  }
  return l;
}


Integer [] myArray = { 1, 2, 3 };
System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList
```

2、最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

3、使用 Java8 的 `Stream`(推荐)

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

4、使用 Guava

对于不可变集合，你可以使用[`ImmutableList`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java)类及其[`of()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101)与[`copyOf()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225)工厂方法：（参数不能为空）

```java
List<String> il = ImmutableList.of("string", "elements");  // from varargs
List<String> il = ImmutableList.copyOf(aStringArray);      // from array
```

对于可变集合，你可以使用[`Lists`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java)类及其[`newArrayList()`open in new window](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87)工厂方法：

```java
List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection
List<String> l2 = Lists.newArrayList(aStringArray);               // from array
List<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs
```

5、使用 Apache Commons Collections

```java
List<String> list = new ArrayList<String>();
CollectionUtils.addAll(list, str);
```

6、 使用 Java9 的 `List.of()`方法

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

### **这里补充一点比较重要，但是容易被忽视掉的知识点：**

- java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.
- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.
- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!



### ArrayList源码&扩容机制分析

#### **最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**

我们通过下面的代码实际测试以下这个方法的效果：

```java
public class EnsureCapacityTest {
	public static void main(String[] args) {
		ArrayList<Object> list = new ArrayList<Object>();
		final int N = 10000000;
		long startTime = System.currentTimeMillis();
		for (int i = 0; i < N; i++) {
			list.add(i);
		}
		long endTime = System.currentTimeMillis();
		System.out.println("使用ensureCapacity方法前："+(endTime - startTime));

	}
}
```

```text
使用ensureCapacity方法前：2158
```

```java
public class EnsureCapacityTest {
    public static void main(String[] args) {
        ArrayList<Object> list = new ArrayList<Object>();
        final int N = 10000000;
        list = new ArrayList<Object>();
        long startTime1 = System.currentTimeMillis();
        list.ensureCapacity(N);
        for (int i = 0; i < N; i++) {
            list.add(i);
        }
        long endTime1 = System.currentTimeMillis();
        System.out.println("使用ensureCapacity方法后："+(endTime1 - startTime1));
    }
}
```

运行结果：

```text
使用ensureCapacity方法后：1773
```

通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数。

### HashMap源码&底层数据结构分析

`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， `HashMap` 总是使用 2 的幂作为哈希表的大小。

### 何为线程?

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

### 线程池运行流程

![图解线程池实现原理](https://javaguide.cn/assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.2b9eb21a.png)

### **什么是钩子方法呢？** 

钩子方法是一种被声明在抽象类中的方法，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。

### 对象的创建

Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。

#### [#](https://javaguide.cn/java/jvm/memory-area.html#step1-类加载检查)Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### [#](https://javaguide.cn/java/jvm/memory-area.html#step2-分配内存)Step2:分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞 ：
  - 适用场合 ：堆内存规整（即没有内存碎片）的情况下。
  - 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表 ：
  - 适用场合 ： 堆内存不规整的情况下。
  - 原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### [#](https://javaguide.cn/java/jvm/memory-area.html#step3-初始化零值)Step3:初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### [#](https://javaguide.cn/java/jvm/memory-area.html#step4-设置对象头)Step4:设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### [#](https://javaguide.cn/java/jvm/memory-area.html#step5-执行-init-方法)Step5:执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

#### [#](https://javaguide.cn/java/jvm/memory-area.html#句柄)句柄

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![对象的访问定位-使用句柄](https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.1cf25227.png)

#### [#](https://javaguide.cn/java/jvm/memory-area.html#直接指针)直接指针

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![对象的访问定位-直接指针](https://javaguide.cn/assets/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.9bfd6702.png)

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

**JDK 1.8 之前** ：

![img](https://javaguide.cn/assets/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.5f095134.png)

**JDK 1.8** ：

![img](https://javaguide.cn/assets/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.dbbe1f77.png)

### JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）

**1．强引用（StrongReference）**

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**2．软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3．弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。
